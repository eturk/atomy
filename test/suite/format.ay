use("core")
use("format")
use("therie")

describe("formatting"):
  describe("chunks of text"):
    it("formats as the text itself"):
      expect(f"foo" []) to be("foo")

    it("has escapes for special format characters"):
      expect(f"\%\(\)\{\}\[\]" []) to be("%(){}[]")

    it("handles other escapes normally"):
      expect(f"\n\t\123\EOT" []) to be("\n\t\123\EOT")

  describe("string (%s)"):
    it("formats a string"):
      expect(f"%s" [1]) to be("1")
      expect(f"%s" ["hello"]) to be("hello")

  describe("decimal (%d)"):
    it("formats an integer in decimal notation"):
      expect(f"%d" [10]) to be("10")

    it("fails with non-integer input"):
      expect { f"%d" ["hello"] } to raise(ArgumentError)

  describe("hexadecimal (%x)"):
    it("formats an integer in hexadecimal notation"):
      expect(f"%x" [10]) to be("a")

    it("fails with non-integer input"):
      expect { f"%x" ["hello"] } to raise(ArgumentError)

  describe("octal (%o)"):
    it("formats an integer in octal notation"):
      expect(f"%o" [10]) to be("12")

    it("fails with non-integer input"):
      expect { f"%o" ["hello"] } to raise(ArgumentError)

  describe("binary (%b)"):
    it("formats an integer in binary notation"):
      expect(f"%b" [10]) to be("1010")

    it("fails with non-integer input"):
      expect { f"%b" ["hello"] } to raise(ArgumentError)

  describe("radix (%r)"):
    it("formats an integer in a given base"):
      expect(f"%.10r" [10]) to be("10")
      expect(f"%.16r" [10]) to be("a")
      expect(f"%.8r" [10]) to be("12")
      expect(f"%.2r" [10]) to be("1010")
      expect(f"%.36r" [35]) to be("z")

    it("fails with non-integer input"):
      expect { f"%.10r" ["hello"] } to raise(ArgumentError)

  describe("floating point (%f)"):
    it("formats a double in general notation"):
      expect(f"%f" [10.0]) to be("10.000000")
      expect(f"%f" [10.5]) to be("10.500000")
      expect(f"%f" [10.54321]) to be("10.543210")

    it("fails with non-float input"):
      expect { f"%f" ["hello"] } to raise(ArgumentError)

    it("accepts a precision flag"):
      expect(f"%.2f" [10.54321]) to be("10.54")
      expect(f"%.2f" [10.545]) to be("10.54")

  describe("exponential (%e)"):
    it("formats a double in exponential notation"):
      expect(f"%e" [10.0]) to be("1.000000e+01")
      expect(f"%e" [10.5]) to be("1.050000e+01")
      expect(f"%e" [10.54321]) to be("1.054321e+01")
      expect((f"%e" [10.12345678901234567890])) to be("1.012346e+01")

    it("fails with non-float input"):
      expect { f"%e" ["hello"] } to raise(ArgumentError)

    it("accepts a precision flag"):
      expect(f"%.2e" [10.54321]) to be("1.05e+01")
      expect(f"%.2e" [10.545]) to be("1.05e+01")
      expect(f"%.2e" [10.12345678901234567890]) to be("1.01e+01")

  describe("general (%g)"):
    it("formats a double in general notation"):
      expect(f"%g" [10.0]) to be("10")
      expect(f"%g" [10.5]) to be("10.5")
      expect(f"%g" [10.54321]) to be("10.5432")
      expect((f"%g" [10000000.12345678901234567890])) to be("1e+07")

    it("fails with non-float input"):
      expect { f"%g" ["hello"] } to raise(ArgumentError)

    it("accepts a precision flag"):
      expect(f"%.2g" [10.54321]) to be("11")
      expect(f"%.2g" [10.545]) to be("11")
      expect((f"%.2g" [10000000.12345678901234567890])) to be("1e+07")

  describe("character (%c)"):
    it("formats a character"):
      expect(f"%c" [97]) to be("a")
      expect(f"%c" ["hi"]) to be("h")
      expect(f"%c" [1.5]) to be("1")

  describe("value (%v)"):
    it("pretty-prints any value"):
      expect(f"%v" [1]) to be("1")
      expect(f"%v" ["hello"]) to be("\"hello\"")

  describe("pluralization (%p)"):
    it("pluralizes a word based on integer input"):
      expect(f"%p(cat)" [1]) to be("cat")
      expect(f"%p(cat)" [2]) to be("cats")

    it("accepts a second field for a specific plural form"):
      expect(f"%p(person)(people)" [1]) to be("person")
      expect(f"%p(person)(people)" [2]) to be("people")

    it("accepts a > flag to not consume the number input"):
      expect(f"%>p(person)(people): %d" [1]) to be("person: 1")
      expect(f"%>p(person)(people): %d" [2]) to be("people: 2")

  describe("lowercase (%l)"):
    it("converts its contents to lowercase"):
      expect(f"%l(%s)" ["HElLo!"]) to be("hello!")

  describe("capitalize (%c)"):
    it("title-cases its contents"):
      expect(f"%c(%s)" ["HElLo, mOm!"]) to be("Hello, Mom!")

    it("accepts a number flag to title-case a certain amount of words"):
      expect(f"%1c(%s)" ["HElLo, mOm!"]) to be("Hello, mOm!")

  describe("uppercase (%u)"):
    it("converts its contents to uppercase"):
      expect(f"%u(%s)" ["hElLo!"]) to be("HELLO!")

  describe("skip (%_)"):
    it("skips an input value"):
      expect(f"%_%d" [1, 2]) to be("2")

    it("accepts a number flag for skipping a certain amount of inputs"):
      expect(f"%2_%d" [1, 2, 3]) to be("3")

    it("accepts a < flag for skipping backards"):
      expect(f"%_%<_%d" [1, 2]) to be("1")
      expect(f"%2_%2<_%d" [1, 2, 3]) to be("1")

  describe("indirection (%%)"):
    it("uses a given format string, followed by a list of inputs"):
      expect(f"%%" [f"%d", [1]]) to be("1")

    it("only consumes its own inputs"):
      expect(f"%%%d" [f"%d", [1], 2]) to be("12")

    it("only skips its own inputs"):
      expect(f"%%%d" [f"%_", [1], 2]) to be("2")

  describe("iteration (%{...})"):
    it("executes a format over a list of inputs"):
      expect(f"%{%d, }" [[1, 2, 3]]) to be("1, 2, 3, ")

    it("accepts a * flag for acting on the rest of the inputs"):
      expect(f"%*{%d, }" [1, 2, 3]) to be("1, 2, 3, ")

    describe("number flag"):
      it("limits the number of iterations"):
        expect(f"%2{%d, }" [[1, 2, 3]]) to be("1, 2, ")

      it("does not cause %^ to break"):
        expect(f"%2{%d%^, }" [[1, 2, 3]]) to be("1, 2, ")

      it("does not iterate with a limit of 0"):
        expect(f"%0{%d, }" [[1, 2, 3]]) to be("")

    describe("+ flag"):
      it("causes iteration to always run at least once"):
        expect(f"%+{hi}" [[]]) to be("hi")
        expect(f"%+{%#[hello]}" [[]]) to be("hello")

      it("overridden by a limit of 0"):
        expect(f"%0+{%d, }" [[1, 2, 3]]) to be("")

    it("accepts a . flag for taking lists of inputs"):
      expect((f"%.{%d: %s\n}" [[[1, "one"], [2, "two"], [3, "three"]]]))
        to be("1: one\n2: two\n3: three\n")

  describe("break (%^)"):
    it("stops an iteration when there are no more inputs"):
      expect(f"%{%d%^, }" [[1, 2, 3]]) to be("1, 2, 3")

    it("stops a sublist iteration only based on the sublist"):
      expect(f"%.{%d%^, }" [[[1], [2, $x], [3]]]) to be("12, 3")

  describe("conditional formatting (%[...]+(...)?)"):
    it("formats the branch at an offset given by the input"):
      expect(f"%[0][1][2]" [0]) to be("0")
      expect(f"%[0][1][2]" [1]) to be("1")

    it("has an optional default branch"):
      expect(f"%[0][1](2+)" [0]) to be("0")
      expect(f"%[0][1](2+)" [1]) to be("1")
      expect(f"%[0][1](2+)" [2]) to be("2+")
      expect(f"%[0][1](2+)" [3]) to be("2+")

    describe("number flag"):
      it("determines which branch gets formatted"):
        expect(f"%0[0][1][2]" []) to be("0")
        expect(f"%1[0][1][2]" []) to be("1")

      it("flows into the default branch"):
        expect(f"%3[0][1][2](3+)" []) to be("3+")

      describe("using #"):
        it("determines which branch gets formatted"):
          expect(f"%#[0][1][2]" []) to be("0")
          expect(f"%#[0][1][2]" [1]) to be("1")
          expect(f"%#[0][1][2]" [1, 2]) to be("2")

        it("flows into the default branch"):
          expect(f"%#[0][1][2](3+)" []) to be("0")
          expect(f"%#[0][1][2](3+)" [1, 2, 3, 4]) to be("3+")

    describe("? flag"):
      describe("one branch"):
        it("consumes a boolean, formatting if it's true"):
          expect(f"%?[yes]" [true]) to be("yes")
          expect(f"%?[yes]" [false]) to be("")

      describe("two or more branches"):
        it("consumes a boolean, formatting the first branch if true, and the second if false"):
          expect(f"%?[yes][no]" [true]) to be("yes")
          expect(f"%?[yes][no]" [false]) to be("no")
          expect(f"%?[yes][no][maybe so]" [true]) to be("yes")
          expect(f"%?[yes][no][maybe so]" [false]) to be("no")

  describe("justification (%j(...)+)"):
    it("justifies one segment to the right side"):
      expect(f"%20j(one)" []) to be("                 one")
      expect((f"%20j(one)" []) length) to be(20)

    it("justifies two segments to left and right sides"):
      expect(f"%20j(one)(two)" []) to be("one              two")
      expect((f"%20j(one)(two)" []) length) to be(20)

    it("attempts to space more than two segments evenly"):
      expect(f"%20j(one)(two)(three)" []) to be("one    two     three")
      expect((f"%20j(one)(two)(three)" []) length) to be(20)
