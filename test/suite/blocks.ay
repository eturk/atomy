use("core")
use("define")
use("therie")

describe("blocks"):
  describe(.call):
    it("evaluates with the block's context available"):
      a = 1
      expect({ a + 1 } call) to be(2)

    it("introduces a new locals environment"):
      a = 1
      expect({ a = 2, a } call) to be(2)
      expect(a) to be(1)

    it("does not leak argument bindings into the block's context"):
      [a] { a + 1 } call(1)
      expect { a } to raise(NameError)

    it("is lexically scoped"):
      a = 1
      foo(b, a) := b call
      expect(foo({ a }, 2)) to be(1)

  describe("arguments"):
    it("errors if too few given"):
      expect({ 1 } call) to be(1)
      expect([a] { a } call(2)) to be(2)
      expect([a, b] { a + b } call(1, 2)) to be(3)

      expect { [a] { a } call } to raise(ArgumentError)
      expect { [a, b] { a } call(1) } to raise(ArgumentError)

    it("errors if too many given"):
      expect { { 1 } call(2) } to raise(ArgumentError)
      expect { { 1 } call(2, 3) } to raise(ArgumentError)

    it("ignores extras if used as a proc-arg"):
      caller &x := x call(1)
      expect(caller: 42) to be(42)
      expect(caller [x]: x + 2) to be(3)

    describe("block"):
      it("binds a block argument"):
        expect(&x { x call } call { 1 }) to be(1)

      it("binds as nil if no block given"):
        expect(&x { x } call) to be(nil)

      it("works with arguments before it"):
        expect([a] &x { x call(a) } call(2) [a] { a + 1 }) to be(3)

      it("fails with arguments after it"):
        expect {
          [&x, a] { x call(a) } call(2) [a] { a + 1 }
        } to raise(ArgumentError)

    describe("splat"):
      it("consumes the rest of the arguments"):
        foo = [*xs]: xs
        expect(foo call) to be([])
        expect(foo call(1)) to be([1])
        expect(foo call(1, 2)) to be([1, 2])

      it("starts after required args"):
        foo = [a, *bs]: [a, bs]
        expect { foo call } to raise(ArgumentError)
        expect(foo call(1)) to be([1, []])
        expect(foo call(1, 2)) to be([1, [2]])
        expect(foo call(1, 2, 3)) to be([1, [2, 3]])

      it("appears before a block arg"):
        foo = [a, *bs] &c: [a, bs, c]
        x = {}
        expect { foo call } to raise(ArgumentError)
        res = foo call(1) &x
        expect(res at(0)) to be(1)
        expect(res at(1)) to be([])
        expect(res at(2)) to be-a(Proc)

        res = foo call(1, 2, 3) &x
        expect(res at(0)) to be(1)
        expect(res at(1)) to be([2, 3])
        expect(res at(2)) to be-a(Proc)

    -- TODO: default, post-args
