use("core")
use("define")

use("therie")

describe("definitions"):
  describe("constant scope"):
    it("retains the proper constant scope for each branch"):
      module:
        Foo = .first
        0 fizz := [0, Foo]

      module:
        Foo = .second
        1 fizz := [1, Foo]

      expect(0 fizz) to be([0, .first])
      expect(1 fizz) to be([1, .second])


  describe("lexical scope"):
    it("captures variables"):
      a = 1
      capturing-simple := a
      expect(capturing-simple) to be(a)

    it("captures variables in loops"):
      objects = [Object new, Object new, Object new]
      objects each with-index [o, x]:
        { o } foo := x

      expect(objects collect .foo) to be([0, 1, 2])


  describe("arguments"):
    describe("required"):
      it("accepts N arguments when expecting N"):
        r0(a, b) := .ok
        expect(r0(1, 2)) to be(.ok)

      it("rejects too few arguments"):
        r1(a, b) := .ok
        expect { r1(1) } to raise(Atomy MethodFail)

      it("rejects too many arguments"):
        r2(a, b) := .ok
        expect { r2(1, 2, 3) } to raise(Atomy MethodFail)


    describe("splats"):
      it("consumes the rest of the arguments"):
        fizz(*args) := args
        expect(fizz()) to be([])
        expect(fizz(1)) to be([1])
        expect(fizz(1, 2)) to be([1, 2])

        xs = [1, 2]
        expect(fizz(*xs)) to be([1, 2])

      it("starts after required args"):
        bar(a, *bs) := [a, bs]
        expect { bar } to raise(Atomy MethodFail)
        expect(bar(1)) to be([1, []])
        expect(bar(1, 2)) to be([1, [2]])
        expect(bar(1, 2, 3)) to be([1, [2, 3]])

      it("works with an explicit receiver"):
        x bar-2(a, *bs) := [x, a, bs]
        expect { bar-2 } to raise(Atomy MethodFail)
        expect(0 bar-2(1)) to be([0, 1, []])
        expect(0 bar-2(1, 2)) to be([0, 1, [2]])
        expect(0 bar-2(1, 2, 3)) to be([0, 1, [2, 3]])

      it("appears before a block arg"):
        baz(a, *bs) &c := [a, bs, c]
        x = :;
        expect { baz } to raise(Atomy MethodFail)
        res = baz(1) &x
        expect(res at(0)) to be(1)
        expect(res at(1)) to be([])
        expect(res at(2)) to be-a(Proc)

        res = baz(1, 2, 3) &x
        expect(res at(0)) to be(1)
        expect(res at(1)) to be([2, 3])
        expect(res at(2)) to be-a(Proc)

    describe("default"):
      it("doesn't have to be passed"):
        d0(b = 1) := b
        expect(d0) to be(1)

      it("may appear after required args"):
        d1(a, b = 1) := [a, b]
        expect(d1(0)) to be([0, 1])

      it("evaluates an expression as its default"):
        d2(a, b = 1 + 1) := [a, b]
        expect(d2(0)) to be([0, 2])

      it("evaluates its default with other args in scope"):
        d3(a, b = a + 1) := [a, b]
        expect(d3(0)) to be([0, 1])

      it("is overrided by an argument"):
        d4(a, b = 3) := [a, b]
        expect(d4(0, 1)) to be([0, 1])

      it("may appear before a block arg"):
        d5(a = 1) &b := [a, b]
        expect(d5) to be([1, nil])
        expect(d5(2)) to be([2, nil])

      it("may appear before a splat arg"):
        d6(a = 1, *b) := [a, b]
        expect(d6) to be([1, []])
        expect(d6(2)) to be([2, []])
        expect(d6(2, 3)) to be([2, [3]])

      it("evaluates its default with the method's context in scope"):
        x = 7
        d7(a, b = x) := [a, b]
        expect(d7(0)) to be([0, 7])

      it("evaluates its default with the other args and the method's context in scope"):
        x = 7
        d8(a, b = a * x) := [a, b]
        expect(d8(6)) to be([6, 42])

    describe("varying argument lengths"):
      it("tries higher required argument counts first"):
        v0(_) := 1
        v0(_, _) := 2

        expect(v0(1)) to be(1)
        expect(v0(1, 2)) to be(2)

      it("does the same when defined in reverse order"):
        v1(_, _) := 2
        v1(_) := 1

        expect(v1(1)) to be(1)
        expect(v1(1, 2)) to be(2)

      it("does not accept extra arguments for other branches"):
        v2(0) := 1
        v2 := 2

        expect(v2(0)) to be(1)
        expect(v2) to be(2)
        expect { v2(1) } to raise(Atomy MethodFail)
