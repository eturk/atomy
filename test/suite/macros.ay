use("core")
use("define")
use("meta")
use("control-flow")
use("therie")

macro(~x m-foo-1): names [x]: `'~x

macro(~x m-foo-2): names [x]: `'([~x]: 1)

macro(~x m-foo-3): names [x]: `'(foo(~x) := 1)

macro(~a m-foo-4): node line

macro(~Block m-foo-7): '1
macro(~Word m-foo-7): '2
macro(~Primitive m-foo-7): '3

macro((~x + 1) m-foo-8): `[~x, 1]

macro((~x + 1) m-foo-9): `1
macro(~Infix m-foo-9): `2

macro(~Infix m-foo-10): `2
macro((~x + 1) m-foo-10): `1

macro(~x m-foo-11): `(macro(~x): '42)
(1 m-foo-110) m-foo-11

macro([~x, ~y] m-foo-12): `(macro(~x): '(macro(~y): '42))
[1 m-foo-120, 1 m-foo-121] m-foo-12
1 m-foo-120

macro(m-foo-18(~_)): '1
macro(m-foo-18(~_, ~_)): '2

macro(m-foo-19(~_, ~_)): '2
macro(m-foo-19(~_)): '1

macro(m-foo-25): '1

macro(default-having(~(x = '42))): x

describe("macros"):
  describe("unique name generation"):
    it("creates names via #names"):
      var-1 = 1 m-foo-1
      var-2 = 2 m-foo-1
      expect(var-1) to be(var-1)
      expect(var-1) to-not be(var-2)

    it("decorates through block patterns"):
      var-1 = 1 m-foo-2
      expect(var-1) to be(var-1)
      expect(1 m-foo-2) to-not be(2 m-foo-2)

    it("decorates through definition patterns"):
      var-1 = 1 m-foo-3
      expect(var-1) to be(var-1)
      expect(1 m-foo-3) to-not be(2 m-foo-3)

  -- TODO: change these to spec #node instead
  describe("line information"):
    it("is provided during macroexpansion via #line"):
      expect(1 m-foo-4) to be(_LINE)
      expect(2 m-foo-4) to be(_LINE)

    -- TODO: investigate proper behaviour; this isn't worth implementing atm
    -- it("retains the original line through multiple expansions"):
      -- macro(a m-foo-5): line
      -- macro(a m-foo-6): `(~a m-foo-5)
      -- expect(1 m-foo-6) to be(_LINE)

  describe("macro definition"):
    it("can pattern-match node types via constants"):
      expect(: 1 ; m-foo-7) to be(1)
      expect(x m-foo-7) to be(2)
      expect(1 m-foo-7) to be(3)

    it("can destructurually pattern-match expressions"):
      expect((2 + 1) m-foo-8) to be([2, 1])

    it("matches destructuring before constants"):
      expect((2 + 1) m-foo-9) to be(1)
      expect((2 + 1) m-foo-10) to be(1)

    it("can specify defaults for arguments"):
      expect(default-having()) to be(42)
      expect(default-having(41)) to be(41)

    it("can define macros in their expansion"):
      expect(1 m-foo-110) to be(42)
      expect { 2 m-foo-110 } to raise(NoMethodError)

    it("can define macros that define macros in their expansion in their expansion"):
      expect(1 m-foo-121) to be(42)
      expect { 2 m-foo-121 } to raise(NoMethodError)

    describe("varying argument lengths"):
      it("tries higher required argument counts first"):
        expect(m-foo-18(1)) to be(1)
        expect(m-foo-18(1, 2)) to be(2)

        expect(m-foo-19(1)) to be(1)
        expect(m-foo-19(1, 2)) to be(2)

  describe("let-macro"):
    it("defines a macro for only its body"):
      m-foo-20 = 0

      let-macro(m-foo-20 = '1):
        expect(m-foo-20) to be(1)

      expect(m-foo-20) to be(0)

    it("can be nested"):
      m-foo-21 = 0

      let-macro(m-foo-21 = '1):
        let-macro(m-foo-21 = '2):
          expect(m-foo-21) to be(2)

        expect(m-foo-21) to be(1)

      expect(m-foo-21) to be(0)

    it("can define multiple macros"):
      m-foo-22 = 0

      let-macro(m-foo-22 = '1, fizzbuzz = '2):
        expect((m-foo-22 + fizzbuzz)) to be(3)

      expect(m-foo-22) to be(0)
      expect { fizzbuzz } to raise(NameError)

    it("lets later macros refer to earlier ones"):
      let-macro(m-foo-23 = '1,
                m-foo-24 = '[0, m-foo-23]):
        expect(m-foo-23) to be(1)
        expect(m-foo-24) to be([0, 1])

    it("overrides non-let'd macros"):
      let-macro(m-foo-25 = '2):
        expect(m-foo-25) to be(2)

      expect(m-foo-25) to be(1)

    it("is available for its own expansion"):
      when-compiling:
        $expanded = 0

      let-macro(foo = if($expanded < 5)
                        then: $expanded += 1, 'foo
                        else: $expanded):
        expect(foo) to be(5)
