<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Pattern Matching</title><link type="text/css" rel="stylesheet" href="public/anatomy.css" /><link type="text/css" rel="stylesheet" href="public/highlight.css" /><script type="text/javascript" src="public/jquery.js"></script><script type="text/javascript" src="public/jquery.hotkeys.js"></script><script type="text/javascript" src="public/tags_pattern-matching.js"></script><script type="text/javascript" src="public/main.js"></script></head><body><div id="main"><div id="content"><div class="section" id="section_pattern-matching"><h1 class="section_header"><a name="pattern-matching"></a>Pattern Matching</h1><p></p><p>At the very heart of Atomy is pattern-matching, and its behavior with dispatch. Patterns are used to both check for and deconstruct a value in one fell swoop. Depending on the scenario, a pattern-match may error if it doesn't match (<code><span class="o">=</span></code>, <code><span class="o">=!</span></code>, and sometimes methods), or just silently fail (<code><span class="n">match</span></code>).</p><p>When defining a method, a few things occur. First, the target of the definition is determined based on the message receiver pattern. See <a href="pattern-matching.html#a-patterns-target">A Pattern's Target</a> for a more detailed account, but you don't have to memorize any of this.</p><p>Once the target is determined, Atomy will check to see if the method is already defined on the target, perhaps with different patterns. If it doesn't exist, the method is simply inserted. If it does, the method is inserted based on its &quot;precision&quot; in relation to the others.</p><p>This sorting is the magic dust. Pattern A is said to be &quot;more precise&quot; than pattern B if it matches fewer cases, or if pattern B will always match what pattern A will match, but not the other way around.</p><p>For example, the pattern <code><span class="mi">1</span></code> is much more precise than the pattern <code><span class="n">x</span></code> - the former only matches the integer <code><span class="mi">1</span></code>, while the latter will match any value! In addition, with two <code><span class="no">Constant</span></code> patterns, one specifying a subclass of the other, the subclass is more precise.</p><p>Care is taken to maintain proper precision-based ordering so that an object may be extended after the fact with method definitions that handle more specific cases. For example, let's say in your original code you define this:</p><div class="highlight"><pre><span class="mi">1</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="mi">-1</span><span class="t">
</span><span class="mi">2</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="mi">-2</span><span class="t">
</span><span class="n">_</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="ss">.umm</span></pre></div><p>Without precision sorting, not only would the order of definitions matter greatly, but no one would be able to handle any other cases! If someone came along and tried defining <code><span class="mi">3</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="mi">-3</span></code>, it would be unreachable, because the wildcard <code><span class="n">_</span></code> matches <em>everything</em>. They'd always get back <code><span class="ss">.umm</span></code> for everything but <code><span class="mi">1</span></code> and <code><span class="mi">2</span></code>. Likewise, if you defined that catch-all case first, it would override the others.</p><p>With precision sorting, things &quot;just work.&quot; You can define your methods in whatever order you want - maybe writing the catch-all first and then drilling into the details afterward. It doesn't matter.</p><div class="section" id="section_types-of-patterns"><h2 class="section_header"><a name="types-of-patterns"></a>Types of Patterns</h2><p>There are a ton of different pattern-matchers that come with Atomy, owing to the fact that they are so easy to define and can provide for immense expressive power.</p><dl><dt><code><span class="n">_</span></code>, <code><span class="n">foo</span></code>, <code><span class="vi">@foo</span></code>, <code><span class="vc">@@foo</span></code>, <code><span class="vg">$foo</span></code>, ...</dt><dd><p>Possibly-named wildcard matches. Global, instance, and class variables behave the same, but bind as their respective types rather than as locals.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">_</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">1</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">a</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">2</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="n">a</span>
<span class="mi">2</span>
</pre></div></div></dd><dt><code><span class="mi">1</span></code>, <code><span class="mf">4.0</span></code>, <code><span class="kc">true</span></code>, <code><span class="kc">false</span></code>, <code><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span></code>, <code><span class="ss">.foo</span></code>, ...</dt><dd><p>Primitive literal values that will match only themselves.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">1</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">2</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Match' did not match value `2'</span>
<span class="caret">&gt; </span><span class="mf">4.0</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mf">4.0</span>
<span class="mf">4.0</span>
<span class="caret">&gt; </span><span class="mf">4.0</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mf">4.000000000001</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Literal' did not match value `4.000000000001'</span>
<span class="caret">&gt; </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
</pre></div></div></dd><dt><code><span class="n">foo</span><span class="p">:</span><span class="t"> </span><span class="n">pattern</span></code>, <code><span class="n">foo</span><span class="t"> </span><span class="p">{</span><span class="t"> </span><span class="n">pattern</span><span class="t"> </span><span class="p">}</span></code></dt><dd><p>A named pattern-match. Matches <code><span class="n">pattern</span></code>, binding the value it matches to a local variable, <code><span class="n">foo</span></code>.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">(</span><span class="n">foo</span><span class="p">:</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">2</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="n">foo</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="n">foo</span><span class="p">:</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">1</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Named' did not match value `1'</span>
</pre></div></div></dd><dt><code><span class="n">head</span><span class="t"> </span><span class="o">.</span><span class="t"> </span><span class="n">tail</span></code></dt><dd><p>Matches a non-empty list, pattern-matching its first value on <code><span class="n">head</span></code> and the rest of it on <code><span class="n">tail</span></code>.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">(</span><span class="n">x</span><span class="t"> </span><span class="o">.</span><span class="t"> </span><span class="n">xs</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="n">x</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">xs</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></dd><dt><code><span class="p">[</span><span class="p">]</span></code>, <code><span class="p">[</span><span class="n">pattern</span><span class="p">,</span><span class="t"> </span><span class="n">pattern-2</span><span class="p">]</span></code>, ...</dt><dd><p>Matches a list of fixed length, recursively matching each <code><span class="n">pattern</span></code> on each of its values.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">[</span><span class="p">]</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="p">[</span><span class="p">]</span>
<span class="p">[</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="t"> </span><span class="n">b</span><span class="p">]</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="t"> </span><span class="n">b</span><span class="p">,</span><span class="t"> </span><span class="n">c</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></dd><dt><code><span class="ss">.foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code>, <code><span class="ss">.foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="t"> </span><span class="n">_</span><span class="p">)</span></code>, ...</dt><dd><p>Matches a particle value, recursively pattern-matching the particle's values. A wildcard in a particle pattern matches placeholders, but no other pattern will.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="ss">.foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">.foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="ss">.foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="caret">&gt; </span><span class="n">x</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="ss">.foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">.foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="ss">.foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="caret">&gt; </span><span class="ss">.foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">.foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="ss">.foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="caret">&gt; </span><span class="ss">.foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">.foo</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Particle' did not match value `.foo(_)'</span>
</pre></div></div></dd><dt><code><span class="ss">'a</span></code>, <code><span class="ss">`a</span></code>, <code><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~b</span><span class="p">)</span></code>, ...</dt><dd><p>Matches expression values recursively. Unquotes serve as nested patterns, with the same recursive semantics as quasiquotation. Splice unquotes are similar, but act as &quot;splats&quot;, matching the rest of its container.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="ss">`a</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">`a</span>
<span class="n">a</span>
<span class="caret">&gt; </span><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~b</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">'</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span>
<span class="caret">&gt; </span><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~</span><span class="ss">'</span><span class="mi">2</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">'</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span>
<span class="caret">&gt; </span><span class="ss">`</span><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~</span><span class="si">~c</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">`</span><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~</span><span class="mi">3</span><span class="p">)</span>
<span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~</span><span class="mi">3</span><span class="p">)</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="t"> </span><span class="n">c</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="ss">`</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="si">~</span><span class="o">*</span><span class="p">[</span><span class="ss">'</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="ss">'</span><span class="mi">4</span><span class="p">]</span><span class="p">]</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">'</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="ss">`</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="si">~</span><span class="o">*</span><span class="n">xs</span><span class="p">]</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">'</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="n">xs</span>
<span class="p">[</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></dd><dt><code><span class="p">{</span><span class="t"> </span><span class="n">expression</span><span class="t"> </span><span class="p">}</span></code></dt><dd><p>Used to target a value's singleton class; <code><span class="n">expression</span></code> is evaluated and its singleton class is the target for a definition. This pattern acts as a wildcard otherwise.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">a</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
<span class="caret">&gt; </span><span class="p">{</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="p">}</span><span class="t"> </span><span class="n">fizz</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="mi">42</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">fizz</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="n">a</span><span class="t"> </span><span class="n">fizz</span>
<span class="mi">42</span>
<span class="caret">&gt; </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="t"> </span><span class="n">fizz</span>
<span class="gr">NoMethodError: undefined method `fizz' on an instance of String.</span>
</pre></div></div></dd><dt><code><span class="o">&amp;</span><span class="n">pattern</span></code></dt><dd><p>Ruby-style proc-arg pattern, used to capture a block passed to a method as a <code><span class="no">Proc</span></code>.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">x</span><span class="t"> </span><span class="n">my-block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="n">y</span><span class="t"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">my_block</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-block</span><span class="p">:</span><span class="t"> </span><span class="mi">42</span>
<span class="gr">Atomy::MethodFail: method 'my_block' does not understand the given arguments: []</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-block</span><span class="t"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="p">:</span><span class="t"> </span><span class="n">x</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span>
<span class="gr">Atomy::MethodFail: method 'my_block' does not understand the given arguments: []</span>
</pre></div></div></dd><dt><code><span class="o">*</span><span class="n">pattern</span></code></dt><dd><p>Ruby-style &quot;splat&quot; pattern, typically used to match the rest of the arguments in a method definition.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">x</span><span class="t"> </span><span class="n">my-splat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="t"> </span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="t"> </span><span class="n">y</span><span class="p">,</span><span class="t"> </span><span class="n">zs</span><span class="p">]</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">my_splat</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-splat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">,</span><span class="t"> </span><span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">,</span><span class="t"> </span><span class="mi">5</span><span class="p">]</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="n">x</span><span class="t"> </span><span class="n">my-splat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="t"> </span><span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="n">zs</span><span class="p">]</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="t"> </span><span class="n">y</span><span class="p">,</span><span class="t"> </span><span class="n">zs</span><span class="p">]</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">my_splat</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-splat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></dd><dt><code><span class="n">pattern</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">default</span></code></dt><dd><p>Ruby-style default argument pattern. Will match <code><span class="n">pattern</span></code> on the argument, or on <code><span class="n">default</span></code>'s value if the argument is not given.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">x</span><span class="t"> </span><span class="n">my-default</span><span class="p">(</span><span class="n">y</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">x</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">1</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="t"> </span><span class="n">y</span><span class="p">]</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">my_default</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-default</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">]</span>
<span class="caret">&gt; </span><span class="mi">1</span><span class="t"> </span><span class="n">my-default</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">42</span><span class="p">]</span>
</pre></div></div></dd><dt><code><span class="n">pattern</span><span class="t"> </span><span class="o">?</span><span class="t"> </span><span class="n">predicate</span></code></dt><dd><p>Matches <code><span class="n">pattern</span></code>, and then evaluates <code><span class="n">predicate</span></code> with the value as <code><span class="bp">self</span></code>, only succeeding if both the match and the predicate succeed.</p><p>If <code><span class="n">pattern</span></code> is not given, <code><span class="n">_</span></code> is assumed.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">(</span><span class="no">Integer</span><span class="t"> </span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">41</span>
<span class="mi">41</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="no">Integer</span><span class="t"> </span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">42</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Predicate' did not match value `42'</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="no">Integer</span><span class="t"> </span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Predicate' did not match value `&quot;foo&quot;'</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">41</span>
<span class="mi">41</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">42</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `Predicate' did not match value `42'</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="o">?</span><span class="t"> </span><span class="n">odd</span><span class="o">?</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span>
<span class="gr">NoMethodError: undefined method `odd?' on an instance of String.</span>
</pre></div></div></dd><dt><code><span class="n">pattern-1</span><span class="t"> </span><span class="o">&amp;</span><span class="t"> </span><span class="n">pattern-2</span></code></dt><dd><p>Succeeds only if both patterns match the value. This is similar to <code><span class="n">foo</span><span class="p">:</span><span class="t"> </span><span class="n">pattern-2</span></code>, but you can specify a pattern rather than a named wildcard in place of <code><span class="n">foo</span></code>.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">(</span><span class="no">Integer</span><span class="t"> </span><span class="o">&amp;</span><span class="t"> </span><span class="mi">41</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">41</span>
<span class="mi">41</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="no">Integer</span><span class="t"> </span><span class="o">&amp;</span><span class="t"> </span><span class="mi">42</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">41</span>
<span class="gr">Atomy::PatternMismatch: pattern of type `And' did not match value `41'</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="n">a</span><span class="t"> </span><span class="o">&amp;</span><span class="t"> </span><span class="n">b</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">x</span>
<span class="gr">NoMethodError: undefined method `x' on #&lt;Atomy::Module:0x3f4b8&gt; (Atomy::Module)</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="t"> </span><span class="n">b</span><span class="p">]</span>
<span class="gr">NoMethodError: undefined method `a' on #&lt;Atomy::Module:0x3f4b8&gt; (Atomy::Module)</span>
</pre></div></div></dd><dt><code><span class="n">pattern-1</span><span class="t"> </span><span class="o">|</span><span class="t"> </span><span class="n">pattern-2</span></code></dt><dd><p>Succeeds if either patterns match the value. This pattern is short-circuiting; if one matches, the other won't be attempted. Therefore, don't rely on bindings in the second pattern being set.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">(</span><span class="n">one</span><span class="t"> </span><span class="o">|</span><span class="t"> </span><span class="n">two</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">41</span>
<span class="mi">41</span>
<span class="caret">&gt; </span><span class="p">[</span><span class="n">one</span><span class="p">,</span><span class="t"> </span><span class="n">two</span><span class="p">]</span>
<span class="gr">NoMethodError: undefined method `two' on #&lt;Atomy::Module:0x3fc80&gt; (Atomy::Module)</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">|</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">2</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">|</span><span class="t"> </span><span class="n">x</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">2</span>
<span class="mi">2</span>
<span class="caret">&gt; </span><span class="n">x</span>
<span class="mi">2</span>
</pre></div></div></dd><dt><code><span class="n">pattern</span><span class="t"> </span><span class="n">with</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span><span class="t"> </span><span class="n">sub-pattern</span><span class="p">)</span></code></dt><dd><p>Matches <code><span class="n">pattern</span></code> on the value. If the match succeeds, matches <code><span class="n">sub-pattern</span></code> on the result of evaluating <code><span class="n">expression</span></code> with the value as <code><span class="bp">self</span></code>. Useful for matching things like instance variables. An omitted <code><span class="n">pattern</span></code> implies <code><span class="n">_</span></code>.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="no">Integer</span><span class="t"> </span><span class="n">with</span><span class="p">(</span><span class="n">odd</span><span class="o">?</span><span class="p">,</span><span class="t"> </span><span class="kc">true</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">1</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">data</span><span class="p">(</span><span class="no">MyPoint</span><span class="p">(</span><span class="vi">@x</span><span class="p">,</span><span class="t"> </span><span class="vi">@y</span><span class="p">)</span><span class="p">)</span>
<span class="kc">nil</span>
<span class="caret">&gt; </span><span class="n">with</span><span class="p">(</span><span class="vi">@x</span><span class="p">,</span><span class="t"> </span><span class="mi">1</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="no">MyPoint</span><span class="t"> </span><span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">BlockEnvironment</span><span class="p">:</span><span class="mh">0x411ac</span><span class="o">&gt;</span>
</pre></div></div></dd></dl></div><div class="section" id="section_a-patterns-target"><h2 class="section_header"><a name="a-patterns-target"></a>A Pattern's Target</h2><p>When defining a method, the receiver in the message-pattern determines where the method is inserted.</p><dl><dt><code><span class="n">_</span></code>, <code><span class="n">foo</span></code>, <code><span class="vi">@foo</span></code>, <code><span class="vc">@@foo</span></code>, <code><span class="vg">$foo</span></code>, ...</dt><dd><p><code><span class="no">Object</span></code></p></dd><dt><code><span class="p">{</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="n">bar</span><span class="t"> </span><span class="p">}</span></code></dt><dd><p><code>foo bar</code>'s singleton class</p></dd><dt><code><span class="no">Foo</span></code>, <code><span class="no">Foo</span><span class="p">:</span><span class="p">:</span><span class="no">Bar</span></code>, <code><span class="p">:</span><span class="p">:</span><span class="no">Bar</span></code>, ...</dt><dd><p>the class named by the constant</p></dd><dt><code><span class="mi">1</span></code>, <code><span class="mi">2</span></code>, ...</dt><dd><p><code><span class="no">Integer</span></code></p></dd><dt><code><span class="kc">true</span></code></dt><dd><p><code><span class="no">TrueClass</span></code></p></dd><dt><code><span class="kc">false</span></code></dt><dd><p><code><span class="no">FalseClass</span></code></p></dd><dt><code><span class="mf">1.0</span></code>, <code><span class="mf">2.0</span></code>, ...</dt><dd><p><code><span class="no">Float</span></code></p></dd><dt><code><span class="s">&quot;</span><span class="s">&quot;</span></code>, <code><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span></code>, ...</dt><dd><p><code><span class="no">String</span></code></p></dd><dt><code><span class="n">head</span><span class="t"> </span><span class="o">.</span><span class="t"> </span><span class="n">tail</span></code>, <code><span class="p">[</span><span class="p">]</span></code>, <code><span class="p">[</span><span class="n">pattern</span><span class="p">,</span><span class="t"> </span><span class="n">pattern-2</span><span class="p">]</span></code>, ...</dt><dd><p><code><span class="no">List</span></code></p></dd><dt><code><span class="ss">'x</span></code>, <code><span class="ss">`x</span></code>, <code><span class="ss">`</span><span class="p">(</span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="si">~y</span><span class="p">)</span></code>, ...</dt><dd><p><code><span class="no">Expression</span></code></p></dd><dt><code><span class="ss">.foo</span></code></dt><dd><p><code><span class="no">Symbol</span></code></p></dd><dt><code><span class="ss">.foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></code></dt><dd><p><code><span class="no">Particle</span></code></p></dd><dt><code><span class="n">foo</span><span class="p">:</span><span class="t"> </span><span class="n">pattern</span></code>, <code><span class="n">foo</span><span class="t"> </span><span class="p">{</span><span class="t"> </span><span class="n">pattern</span><span class="t"> </span><span class="p">}</span></code></dt><dd><p>target of <em>pattern</em></p></dd><dt><code><span class="n">pattern</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">default</span></code></dt><dd><p>target of <em>pattern</em></p></dd><dt><code><span class="n">pattern</span><span class="t"> </span><span class="o">?</span><span class="t"> </span><span class="n">predicate</span></code></dt><dd><p>target of <em>pattern</em></p></dd><dt><code><span class="o">?</span><span class="t"> </span><span class="n">predicate</span></code></dt><dd><p><code><span class="no">Object</span></code></p></dd><dt><code><span class="n">pattern-1</span><span class="t"> </span><span class="o">&amp;</span><span class="t"> </span><span class="n">pattern-2</span></code></dt><dd><p>target of <em>pattern-1</em></p></dd><dt><code><span class="n">pattern-1</span><span class="t"> </span><span class="o">|</span><span class="t"> </span><span class="n">pattern-2</span></code></dt><dd><p>target of <em>pattern-1</em></p></dd><dt><code><span class="n">pattern-1</span><span class="t"> </span><span class="n">with</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span><span class="t"> </span><span class="n">pattern-2</span><span class="p">)</span></code></dt><dd><p>target of <em>pattern-1</em></p></dd><dt><code><span class="o">&amp;</span><span class="n">foo</span></code>, <code><span class="o">*</span><span class="n">foo</span></code></dt><dd><p><code><span class="no">Object</span></code></p></dd></dl><p>Thus, <code><span class="mi">1</span><span class="t"> </span><span class="n">foo</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="n">x</span></code> is a definition placed on <code><span class="no">Integer</span></code>, while <code><span class="p">{</span><span class="t"> </span><span class="bp">self</span><span class="t"> </span><span class="p">}</span><span class="t"> </span><span class="n">foo</span></code> is inserted on <code><span class="bp">self</span></code>'s singleton class, similar to <code>def self.foo; ...; end</code> in Ruby.</p></div></div></div></div><div class="search"><form action="javascript:void(0)"><input type="text" placeholder="Search&hellip;" autocomplete="off" id="search" /></form><ul class="search_results"></ul></div><div id="sidebar"><h4>On this page:</h4><ol class="toc"><li><a href="pattern-matching.html#types-of-patterns">Types of Patterns</a></li><li><a href="pattern-matching.html#a-patterns-target">A Pattern's Target</a></li></ol><h4>Up one level:</h4><ol class="toc"><li><a href="index.html">Atomy</a><ol><li><a href="why.html">What &amp; Why</a><ol><li><a href="why.html#philosophy">Philosophy</a></li><li><a href="why.html#idioms-and-freebies">Idioms &amp; Freebies</a><ol><li><a href="why.html#platform">Platform</a></li><li><a href="why.html#its-algebraic">It's Algebraic!</a></li><li><a href="why.html#a-handful-of-shiny-toys">A Handful of Shiny Toys</a></li></ol></li><li><a href="why.html#influences-and-thanks">Influences &amp; Thanks</a></li></ol></li><li><a href="syntax.html">Syntax</a><ol><li><a href="syntax.html#general-rules">General Rules</a></li><li><a href="syntax.html#comments">Comments</a></li><li><a href="syntax.html#literals-syntax">Literals</a></li><li><a href="syntax.html#expressions">Expressions</a></li><li><a href="syntax.html#language"><code><span class="kr">#language</span></code></a></li></ol></li><li><a href="pattern-matching.html">Pattern Matching</a><ol><li><a href="pattern-matching.html#types-of-patterns">Types of Patterns</a></li><li><a href="pattern-matching.html#a-patterns-target">A Pattern's Target</a></li></ol></li><li><a href="reference.html">Reference</a><ol><li><a href="concurrency.html">Concurrency</a><ol><li><a href="concurrency.html#sending-and-receiving">Sending &amp; Receiving</a></li><li><a href="concurrency.html#spawning">Spawning</a></li></ol></li><li><a href="condition-system.html">Condition System</a><ol><li><a href="condition-system.html#conditions">Conditions</a></li><li><a href="condition-system.html#handling">Handling</a></li><li><a href="condition-system.html#signalling">Signalling</a></li><li><a href="condition-system.html#debuggers">Debuggers</a></li></ol></li><li><a href="core.html">Core</a></li><li><a href="input-and-output.html">Input &amp; Output</a><ol><li><a href="input-and-output.html#output">Output</a></li><li><a href="input-and-output.html#input">Input</a></li></ol></li><li><a href="the-repl.html">The REPL</a></li><li><a href="therie.html">Testing with Therie</a><ol><li><a href="therie.html#structure">Structure</a></li><li><a href="therie.html#tests">Tests</a></li></ol></li></ol></li></ol></li></ol></div></body></html>