<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>What &amp; Why</title><link type="text/css" rel="stylesheet" href="public/anatomy.css" /><link type="text/css" rel="stylesheet" href="public/highlight.css" /><script type="text/javascript" src="public/jquery.js"></script><script type="text/javascript" src="public/jquery.hotkeys.js"></script><script type="text/javascript" src="public/tags_why.js"></script><script type="text/javascript" src="public/main.js"></script></head><body><div id="main"><div id="content"><div class="section" id="section_why"><h1 class="section_header"><a name="why"></a>What &amp; Why</h1><p></p><div class="section" id="section_philosophy"><h2 class="section_header"><a name="philosophy"></a>Philosophy</h2><p>Atomy is a language designed to grow. It achieves this goal by having a very simple grammar, much like Lisp. Rather than statements, everyting in Atomy is an expression. These expressions are not merely written, they are <em>designed</em>. Readability, concision, and flow are the primary goal, and this goal is most easily achieved by keeping the grammar small, and building everything up from there with macros and metaprogramming.</p><p>Time after time new languages are introduced, which are often snapshots of what we needed when it was designed. These languages have so many features built-in as syntax that countless libraries and applications hinge on version numbers solely to get past the parsing stage. Ruby and Python are examples of these.</p><p>Atomy instead hopes to introduce these features as libraries. The grammar in 1.0 should either be &quot;the end&quot; of its progression, or later generalized in a way that is backward-compatble.</p></div><div class="section" id="section_idioms-and-freebies"><h2 class="section_header"><a name="idioms-and-freebies"></a>Idioms &amp; Freebies</h2><div class="section" id="section_platform"><h3 class="section_header"><a name="platform"></a>Platform</h3><p>Atomy's platform of choice is the Rubinius VM. Its syntax already scales upward to encompass every common Ruby construct (with its own flavor), and Ruby libraries can be used transparently, as long as they run on Rubinius.</p></div><div class="section" id="section_its-algebraic"><h3 class="section_header"><a name="its-algebraic"></a>It's Algebraic!</h3><p>An integral part of Atomy's core is pattern-matching dispatch. This gives you immense expressive power, with a form of multiple dispatch. Atomy's style favors declaring your data structures first and defining methods in a functional style in terms of all of their &quot;roles&quot; (the receiver and the message's arguments).</p><p>To show this, I'll go through part of the the <code><span class="no">Doc</span></code> system, used for pretty-printing, which exemplifies this beautifully.</p><p>Here we define each type of <code><span class="no">Doc</span></code> there is, structurally. This creates classes and subclasses recursively, as well as constructors and accessors for the data they specify:</p><div class="highlight"><pre><span class="n">data</span><span class="p">(</span><span class="no">Doc</span><span class="p">)</span><span class="p">:</span><span class="t">
  </span><span class="no">Empty</span><span class="t">
  </span><span class="no">Beside</span><span class="p">(</span><span class="vi">@left</span><span class="p">,</span><span class="t"> </span><span class="vi">@right</span><span class="p">,</span><span class="t"> </span><span class="vi">@space</span><span class="o">?</span><span class="p">)</span><span class="t">
  </span><span class="no">Above</span><span class="p">(</span><span class="vi">@above</span><span class="p">,</span><span class="t"> </span><span class="vi">@below</span><span class="p">,</span><span class="t"> </span><span class="vi">@overlap</span><span class="o">?</span><span class="p">)</span><span class="t">
  </span><span class="no">Text</span><span class="p">(</span><span class="vi">@value</span><span class="p">)</span></pre></div><p>One thing we'll want to do with a document is compute its width. This is trivial; just a single message sent to the <code><span class="no">Doc</span></code> with no arguments. Note that we're defining each method alongside one another; not inside of a class body. This allows us to group related methods by meaning, not by their receiver. This better shows the relationships between each method:</p><div class="highlight"><pre><span class="no">Empty</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="mi">0</span><span class="t">
</span><span class="no">Text</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="vi">@value</span><span class="t"> </span><span class="n">size</span><span class="t">
</span><span class="no">Beside</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">:=</span><span class="t">
  </span><span class="n">if</span><span class="p">(</span><span class="vi">@space</span><span class="o">?</span><span class="p">)</span><span class="t">
    </span><span class="n">then</span><span class="p">:</span><span class="t"> </span><span class="mi">1</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="vi">@left</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="vi">@right</span><span class="t"> </span><span class="n">width</span><span class="t">
    </span><span class="n">else</span><span class="p">:</span><span class="t"> </span><span class="vi">@left</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="vi">@right</span><span class="t"> </span><span class="n">width</span><span class="t">
</span><span class="no">Above</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="p">[</span><span class="vi">@above</span><span class="t"> </span><span class="n">width</span><span class="p">,</span><span class="t"> </span><span class="vi">@below</span><span class="t"> </span><span class="n">width</span><span class="p">]</span><span class="t"> </span><span class="n">max</span></pre></div><p>A great example of pattern-matching and multiple dispatch comes into play when composing two documents with the <code>&lt;+&gt;</code> operator. This positions two <code><span class="no">Doc</span></code>s beside each other, separated by a space, unless either are <code><span class="no">Empty</span></code>:</p><div class="highlight"><pre><span class="p">(</span><span class="n">l</span><span class="p">:</span><span class="t"> </span><span class="no">Doc</span><span class="p">)</span><span class="t"> </span><span class="o">&lt;+&gt;</span><span class="t"> </span><span class="p">(</span><span class="n">r</span><span class="p">:</span><span class="t"> </span><span class="no">Doc</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="no">Beside</span><span class="t"> </span><span class="n">new</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="t"> </span><span class="n">r</span><span class="p">,</span><span class="t"> </span><span class="kc">true</span><span class="p">)</span><span class="t">
</span><span class="p">(</span><span class="n">d</span><span class="p">:</span><span class="t"> </span><span class="no">Doc</span><span class="p">)</span><span class="t"> </span><span class="o">&lt;+&gt;</span><span class="t"> </span><span class="no">Empty</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="n">d</span><span class="t">
</span><span class="no">Empty</span><span class="t">    </span><span class="o">&lt;+&gt;</span><span class="t"> </span><span class="p">(</span><span class="n">d</span><span class="p">:</span><span class="t"> </span><span class="no">Doc</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="n">d</span><span class="t">
</span><span class="p">(</span><span class="n">l</span><span class="p">:</span><span class="t"> </span><span class="no">Doc</span><span class="p">)</span><span class="t"> </span><span class="o">&lt;+&gt;</span><span class="t"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="t"> </span><span class="no">Above</span><span class="p">)</span><span class="t"> </span><span class="o">:=</span><span class="t"> </span><span class="n">do</span><span class="p">:</span><span class="t">
  </span><span class="n">first</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">l</span><span class="t"> </span><span class="o">&lt;+&gt;</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="n">above</span><span class="t">
  </span><span class="n">rest</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="n">below</span><span class="t"> </span><span class="n">nest</span><span class="p">(</span><span class="n">l</span><span class="t"> </span><span class="n">width</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">1</span><span class="p">)</span><span class="t">
  </span><span class="no">Above</span><span class="t"> </span><span class="n">new</span><span class="p">(</span><span class="n">first</span><span class="p">,</span><span class="t"> </span><span class="n">rest</span><span class="p">,</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="n">overlap</span><span class="o">?</span><span class="p">)</span></pre></div><p>This is opposed to Ruby-style, where you open classes to add methods to them, and then handle the arguments from within the single method definition, often with the <code>case</code> statement. This form is also supported, but it is much more verbose.</p></div><div class="section" id="section_a-handful-of-shiny-toys"><h3 class="section_header"><a name="a-handful-of-shiny-toys"></a>A Handful of Shiny Toys</h3><dl><dt>a syntax-oriented macro system</dt><dd><p>Atomy has a small grammar independent from its language semantics. For example, there is no &quot;message send&quot; primitive node, and there aren't class/global/instance variable primitives. These are defined using Atomy's all-powerful macro system.</p><p>You may be familiar with macros from Common Lisp, Scheme, or Clojure. In these languages a macro is a special named function that takes its arguments unevaluated, and builds another form for evaluating later. You may also know them from C/C++ as primitive text rewriting mechanisms.</p><p>Atomy goes somewhere neither really cover: its macros aren't named anything; they expand arbitrary expressions. I probably shouldn't be showing you this, but...</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">macro</span><span class="p">(</span><span class="mi">2</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span><span class="p">)</span><span class="p">:</span><span class="t"> </span><span class="mi">5</span>
<span class="o">#&lt;</span><span class="no">Rubinius</span><span class="p">:</span><span class="p">:</span><span class="no">CompiledMethod</span><span class="t"> </span><span class="n">_expand_</span><span class="o">+</span><span class="t"> </span><span class="n">file</span><span class="o">=</span><span class="n">wrapper</span><span class="o">&gt;</span>
<span class="caret">&gt; </span><span class="mi">2</span><span class="t"> </span><span class="o">+</span><span class="t"> </span><span class="mi">2</span>
<span class="mi">5</span>
</pre></div></div></dd><dt>macro-quotes</dt><dd><p>Generalized string quotation. Examples include regular expressions, raw strings, and word-lists. It's easy to create new quoters for things other languages would have as literals.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">r</span><span class="s">&quot;</span><span class="s">[</span><span class="s">a</span><span class="s">-</span><span class="s">z</span><span class="s">]</span><span class="s">[</span><span class="s">\p</span><span class="s">{</span><span class="s">L</span><span class="s">}</span><span class="s">]</span><span class="s">*</span><span class="s">&quot;</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="o">/</span><span class="p">[</span><span class="n">a-z</span><span class="p">]</span><span class="p">[</span><span class="o">\</span><span class="n">p</span><span class="p">{</span><span class="no">L</span><span class="p">}</span><span class="p">]</span><span class="o">*/</span><span class="n">u</span>
<span class="caret">&gt; </span><span class="n">raw</span><span class="s">&quot;</span><span class="s">s</span><span class="s">\u</span><span class="s">p</span><span class="s">?</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="s">s</span><span class="se">\</span><span class="se">\</span><span class="s">up?</span><span class="s">&quot;</span>
<span class="caret">&gt; </span><span class="n">w</span><span class="s">&quot;</span><span class="s">f</span><span class="s">o</span><span class="s">o</span><span class="s"> </span><span class="s">b</span><span class="s">a</span><span class="s">r</span><span class="s"> </span><span class="s">b</span><span class="s">a</span><span class="s">z</span><span class="s">&quot;</span>
<span class="p">[</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span class="t"> </span><span class="s">&quot;</span><span class="s">bar</span><span class="s">&quot;</span><span class="p">,</span><span class="t"> </span><span class="s">&quot;</span><span class="s">baz</span><span class="s">&quot;</span><span class="p">]</span>
</pre></div></div></dd><dt>explicit mutation</dt><dd><p>Atomy has two &quot;assignment&quot;-ish operators; <code><span class="o">=</span></code> and <code><span class="o">=!</span></code>. The former will always pattern-match and introduce locals to the current immediate scope. The latter will also pattern-match, but it will only <em>mutate</em> existing locals, never introducing them.</p><p>This keeps your locals local and makes it clear when you really want to mutate something in-place.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="n">a</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">0</span>
<span class="mi">0</span>
<span class="caret">&gt; </span><span class="n">do</span><span class="p">:</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="n">a</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">a</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">do</span><span class="p">:</span><span class="t"> </span><span class="n">a</span><span class="t"> </span><span class="o">=!</span><span class="t"> </span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="n">a</span>
<span class="mi">1</span>
<span class="caret">&gt; </span><span class="n">a</span>
<span class="mi">1</span>
</pre></div></div></dd><dt>syntax as macros</dt><dd><p>Where Ruby has global, instance, and class variable syntax, Atomy actually implements these as prefix macros. The same goes for for symbols (<code><span class="ss">.to-a</span></code>), particles (<code><span class="ss">.foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="n">_</span><span class="p">)</span></code>, splats (<code><span class="o">*</span><span class="n">args</span></code>), block-passing (<code><span class="o">&amp;</span><span class="n">foo</span></code>), and a few others. If something can be a macro or regular method, it will be. This has been applied very broadly.</p></dd><dt>particles</dt><dd><p>Like Atomo, Atomy has a concept of &quot;partial messages&quot; which can act as ad-hoc data structures. They respond to <code><span class="n">call</span></code> and <code><span class="n">to-proc</span></code>, so you can use them as block shorthand.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="mi">2</span><span class="p">,</span><span class="t"> </span><span class="mi">3</span><span class="p">]</span><span class="t"> </span><span class="n">collect</span><span class="t"> </span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="t"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="t"> </span><span class="mi">6</span><span class="p">,</span><span class="t"> </span><span class="mi">9</span><span class="p">]</span>
</pre></div></div><p>You can also pattern-match them, so they are often used for simple data structures, similar to how atoms and tuples are used in Erlang.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="ss">.ok</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="t"> </span><span class="o">=</span><span class="t"> </span><span class="ss">.ok</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="ss">.ok</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="caret">&gt; </span><span class="n">x</span>
<span class="mi">1</span>
</pre></div></div><p>In a particle, <code>_</code> acts as a placeholder. Sending <code><span class="n">call</span></code> will fill these values in order with the values you pass, and then send the message.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="ss">.is-a</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">?</span><span class="t"> </span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="t"> </span><span class="no">Integer</span><span class="p">)</span>
<span class="kc">true</span>
</pre></div></div><p>Note that they have very similar syntax as <code><span class="no">Symbol</span></code>s; in fact, Atomy also defines <code><span class="n">call</span></code> on <code><span class="no">Symbol</span></code> so you can generally use them interchangeably.</p><div class="example"><p><p><em>Example:</em></p></p><div class="interaction"><pre><span class="caret">&gt; </span><span class="ss">.odd</span><span class="o">?</span><span class="t"> </span><span class="n">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="kc">true</span>
<span class="caret">&gt; </span><span class="ss">.odd</span><span class="o">?</span><span class="t"> </span><span class="n">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="kc">false</span>
</pre></div></div></dd><dt>extensible pattern-matching</dt><dd><p>If you don't mind digging down into Rubinius bytecode, you can define your own pattern-matchers. It's very easy to do, and there is a very broad spectrum of pattern-matchers built-in because of this. See <a href="pattern-matching.html">pattern-matching</a>.</p></dd></dl></div></div><div class="section" id="section_influences-and-thanks"><h2 class="section_header"><a name="influences-and-thanks"></a>Influences &amp; Thanks</h2><dl><dt>Common Lisp &amp; Clojure</dt><dd><p>extensive macro system, gensyms (via <code><span class="n">names</span></code>), powerful string formatting system, conditions &amp; restarts, thread-local dynamic environment (via <code><span class="n">dynamic</span></code>), controlled evaluation (via <code><span class="n">evaluate-when</span></code> and <code><span class="n">for-macro</span></code>), <code><span class="n">let-macro</span></code>, dynamic variable -based <a href="input-and-output.html">Input &amp; Output</a>, Clojure-style namespaces</p></dd><dt>Haskell</dt><dd><p>pattern-matching, algebraic data definition (via <code><span class="n">data</span></code>), functional-style method defining, pretty-printing system, parens slaying with <code><span class="o">$</span></code>, list comprehension macros</p></dd><dt>Ruby</dt><dd><p>functionality baseline, with desired improvements (selector namespacing, safer alternatives to <code>instance_eval</code> for DSLs, like <code><span class="n">onto</span></code>)</p></dd><dt>Slate &amp; Atomo</dt><dd><p>multiple dispatch (via pattern-matching, like Atomo; Slate doesn't work that way), particles, pseudo-keyword-messages via macros and pattern-matching</p></dd><dt>Potion &amp; Poison</dt><dd><p>colon block syntax + commas</p></dd><dt>Erlang</dt><dd><p>message-sending concurrency</p></dd></dl></div></div></div></div><div class="search"><form action="javascript:void(0)"><input type="text" placeholder="Search&hellip;" autocomplete="off" id="search" /></form><ul class="search_results"></ul></div><div id="sidebar"><h4>On this page:</h4><ol class="toc"><li><a href="why.html#philosophy">Philosophy</a></li><li><a href="why.html#idioms-and-freebies">Idioms &amp; Freebies</a><ol><li><a href="why.html#platform">Platform</a></li><li><a href="why.html#its-algebraic">It's Algebraic!</a></li><li><a href="why.html#a-handful-of-shiny-toys">A Handful of Shiny Toys</a></li></ol></li><li><a href="why.html#influences-and-thanks">Influences &amp; Thanks</a></li></ol><h4>Up one level:</h4><ol class="toc"><li><a href="index.html">Atomy</a><ol><li><a href="why.html">What &amp; Why</a><ol><li><a href="why.html#philosophy">Philosophy</a></li><li><a href="why.html#idioms-and-freebies">Idioms &amp; Freebies</a><ol><li><a href="why.html#platform">Platform</a></li><li><a href="why.html#its-algebraic">It's Algebraic!</a></li><li><a href="why.html#a-handful-of-shiny-toys">A Handful of Shiny Toys</a></li></ol></li><li><a href="why.html#influences-and-thanks">Influences &amp; Thanks</a></li></ol></li><li><a href="syntax.html">Syntax</a><ol><li><a href="syntax.html#general-rules">General Rules</a></li><li><a href="syntax.html#comments">Comments</a></li><li><a href="syntax.html#literals-syntax">Literals</a></li><li><a href="syntax.html#expressions">Expressions</a></li><li><a href="syntax.html#language"><code><span class="kr">#language</span></code></a></li></ol></li><li><a href="pattern-matching.html">Pattern Matching</a><ol><li><a href="pattern-matching.html#types-of-patterns">Types of Patterns</a></li><li><a href="pattern-matching.html#a-patterns-target">A Pattern's Target</a></li></ol></li><li><a href="reference.html">Reference</a><ol><li><a href="concurrency.html">Concurrency</a><ol><li><a href="concurrency.html#sending-and-receiving">Sending &amp; Receiving</a></li><li><a href="concurrency.html#spawning">Spawning</a></li></ol></li><li><a href="condition-system.html">Condition System</a><ol><li><a href="condition-system.html#conditions">Conditions</a></li><li><a href="condition-system.html#handling">Handling</a></li><li><a href="condition-system.html#signalling">Signalling</a></li><li><a href="condition-system.html#debuggers">Debuggers</a></li></ol></li><li><a href="core.html">Core</a></li><li><a href="input-and-output.html">Input &amp; Output</a><ol><li><a href="input-and-output.html#output">Output</a></li><li><a href="input-and-output.html#input">Input</a></li></ol></li><li><a href="the-repl.html">The REPL</a></li><li><a href="therie.html">Testing with Therie</a><ol><li><a href="therie.html#structure">Structure</a></li><li><a href="therie.html#tests">Tests</a></li></ol></li></ol></li></ol></li></ol></div></body></html>