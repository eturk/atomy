use(require("core"))
use(require("define"))
use(require("control-flow"))

require("atomy/pattern/index")
require("atomy/pattern/instance_variable")
require("atomy/pattern/attribute")
require("atomy/pattern/or")

pattern(~parent ~(constant & Constant)):
  Atomy Code Pattern new(`(//Atomy Pattern KindOf new(~parent ~constant)), [])

pattern(~receiver ~(attribute & Word)):
  Atomy Code Pattern new(`(//Atomy Pattern Attribute new('~attribute text, ~receiver)), [])

pattern(~receiver [~*arguments]):
  Atomy Code Pattern new(`(//Atomy Pattern Index new(~receiver, [~*arguments])), [])

pattern(@~(name & Word)):
  Atomy Code Pattern new(`(//Atomy Pattern InstanceVariable new('~name text)), [])

pattern(~a | ~b):
  a-pattern = pattern(a)
  b-pattern = pattern(b)

  Atomy Code Pattern new(
      `(//Atomy Pattern Or new(~a-pattern, ~b-pattern))
      a-pattern locals + b-pattern locals)

Atomy Pattern open:
  const-set(.With, class:
    def(initialize(@block, @pattern)) {}

    def(matches?(val)):
      @pattern matches?(@block call-on-object(val))

    def(assign(scope, val)):
      @pattern assign(scope, @block call-on-object(val))
  )

pattern(with(~expr, ~pat)):
  sub-pattern = pattern(pat)

  Atomy Code Pattern new(
    `(//Atomy Pattern With new({ ~expr }, ~sub-pattern))
    sub-pattern locals)

list-pattern = class:
  def(initialize(patterns)):
    @patterns = []

    patterns each [p]:
      if(p is-a?(Atomy Pattern Splat))
        then: @splat = p -- TODO: break
        else: @patterns << p

  def(matches?(val)):
    when(@splat && (val size < @patterns size)):
      return(false)

    when(!@splat && (val size != @patterns size)):
      return(false)

    idx = 0
    mismatch = false
    @patterns each [p]:
      unless(p matches?(val[idx])):
        mismatch =! true
        -- TODO: break, or return false

      idx =! (idx + 1)

    if(mismatch)
      then: false
      else:

    if(@splat)
      then: @splat matches?(val drop(idx))
      else: true

  def(assign(scope, val)):
    idx = 0
    @patterns each [p]:
      p assign(scope, val[idx])
      idx =! (idx + 1)

    when(@splat):
      @splat assign(scope, val drop(idx))

Atomy Pattern const-set(.List, list-pattern)

pattern([~*pats]):
  sub-patterns = pats collect [p]: pattern(p)

  Atomy Code Pattern new(
      `(//Atomy Pattern List new([~*sub-patterns]))
      sub-patterns collect [p] { p locals } flatten)
