use(require("core"))
use(require("define"))
use(require("control-flow"))

require("atomy/pattern/index")
require("atomy/pattern/instance_variable")
require("atomy/pattern/attribute")
require("atomy/pattern/or")

pattern(~parent ~(constant & Constant)):
  Atomy Code Pattern new(`(//Atomy Pattern KindOf new(~parent ~constant)), [])

pattern(~receiver ~(attribute & Word)):
  Atomy Code Pattern new(`(//Atomy Pattern Attribute new('~attribute text, ~receiver)), [])

pattern(~receiver [~*arguments]):
  Atomy Code Pattern new(`(//Atomy Pattern Index new(~receiver, [~*arguments])), [])

pattern(@~(name & Word)):
  Atomy Code Pattern new(`(//Atomy Pattern InstanceVariable new('~name text)), [])

pattern($~(name & Word)):
  pattern(`(//Rubinius Globals[~(Atomy Code Symbol new(("$" + name text to-s) to-sym))]))

pattern(~a | ~b):
  a-pattern = pattern(a)
  b-pattern = pattern(b)

  Atomy Code Pattern new(
      `(//Atomy Pattern Or new(~a-pattern, ~b-pattern))
      a-pattern locals + b-pattern locals)

with-pattern = Atomy Pattern class:
  def(initialize(@block, @pattern)) {}

  def(matches?(val)):
    @pattern matches?(@block call-on-object(val))

  def(assign(scope, val)):
    @pattern assign(scope, @block call-on-object(val))

  def(target):
    Object

Atomy Pattern const-set(.With, with-pattern)

pattern(with(~expr, ~pat)):
  sub-pattern = pattern(pat)

  Atomy Code Pattern new(
    `(//Atomy Pattern With new({ ~expr }, ~sub-pattern))
    sub-pattern locals)

list-pattern = Atomy Pattern class:
  def(initialize(patterns)):
    @patterns = []

    patterns each [p]:
      if(p is-a?(Atomy Pattern Splat))
        then: @splat = p -- TODO: break
        else: @patterns << p

  def(matches?(val)):
    when(@splat && (val size < @patterns size)):
      return(false)

    when(!@splat && (val size != @patterns size)):
      return(false)

    idx = 0
    mismatch = false
    @patterns each [p]:
      unless(p matches?(val[idx])):
        mismatch =! true
        -- TODO: break, or return false

      idx =! (idx + 1)

    if(mismatch)
      then: false
      else:

    if(@splat)
      then: @splat matches?(val drop(idx))
      else: true

  def(assign(scope, val)):
    idx = 0
    @patterns each [p]:
      p assign(scope, val[idx])
      idx =! (idx + 1)

    when(@splat):
      @splat assign(scope, val drop(idx))

Atomy Pattern const-set(.List, list-pattern)

pattern([~*pats]):
  sub-patterns = pats collect [p]: pattern(p)

  Atomy Code Pattern new(
      `(//Atomy Pattern List new([~*sub-patterns]))
      sub-patterns collect [p] { p locals } flatten)

match = class:
  def(initialize(@node, @branches)) {}

  def(bytecode(gen, mod)):
    gen create-block(build-block(gen state scope, mod))
    mod compile(gen, @node)
    gen send(.call, 1)


  def(build-block(scope, mod)):
    Atomy Compiler generate(mod file) [blk]:
      -- close over the outer scope
      blk state scope parent = scope

      blk total-args = 1
      blk required-args = 1
      blk arity = 1

      pairs = @branches collect [`(~pat: ~*body)]:
        [mod pattern(pat), `(do: ~*body)]

      -- create a local for the value being matched against
      blk state scope new-local(."arg:match-value")

      -- [node]
      blk push-local(0)

      done = blk new-label

      pairs each [pair]:
        pat = pair[0]
        body = pair[1]

        skip = blk new-label

        -- [pattern, node]
        mod compile(blk, pat)

        -- [pattern, node, pattern, node]
        blk dup-many(2)

        -- [node, pattern, pattern, node]
        blk swap

        -- [bool, pattern, node]
        blk send(.matches?, 1)

        -- [pattern, node]
        blk gif(skip)

        pat locals each [name]:
          assigned = assignment-local(blk, name)
          local = assigned[0]
          created = assigned[1]
          when(created):
            blk push-nil
            local set-bytecode(blk)
            blk pop

        -- [node, pattern]
        blk swap

        -- [#<Rubinius::VariableScope>, node, pattern]
        blk push-variables

        -- [node, #<Rubinius::VariableScope>, pattern]
        blk swap

        -- [<junk>]
        blk send(.assign, 2)

        -- []
        blk pop

        -- [value]
        mod compile(blk, body)

        -- [value]
        blk goto(done)

        -- [pattern, node]
        skip set!

        -- [node]
        blk pop

      -- []
      blk pop

      -- [value]
      blk push-nil

      -- [value]
      done set!

  def(assignment-local(gen, name)):
    var = gen state scope search-local(name)

    if(var && (var depth == 0))
      then: [var, false]
      else: [gen state scope new-local(name) nested-reference, true]


macro(~x match: ~*branches):
  match new(x, branches)

rescue = class:
  def(initialize(@node, @branches)) {}

  -- TODO: this is pretty barebones compared to:
  -- https://github.com/rubinius/rubinius-ast/blob/aa5ff6260a7647a9ef1035feb66b6d4b632d4211/lib/rubinius/ast/exceptions.rb
  -- i'd rather prove out the complexity than blindly mirror it
  def(bytecode(gen, mod)):
    ok = gen new-label
    ex = gen new-label
    rescued = gen new-label

    -- []
    gen setup-unwind(ex, 0) -- RescueType

    -- [value]
    mod compile(gen, @node)

    -- [value]
    gen pop-unwind
  
    -- [value]
    gen goto(ok)

    ex set!

    -- []
    -- gen pop

    -- [exc_state]
    gen push-exception-state

    -- [block, exc_state]
    gen create-block(build-block(gen state scope, mod))

    -- [exc, block, exc_state]
    gen push-current-exception

    -- [value, exc_state]
    gen send(.call, 1)

    -- [value, value, exc_state]
    gen dup

    -- [value, exc_state]
    gen goto-if-not-undefined(rescued)

    -- [exc_state]
    gen pop

    -- []
    gen restore-exception-state

    -- []
    gen reraise
  
    -- [value, exc_state]
    rescued set!

    -- [exc_state, value]
    gen swap

    -- [value]
    gen pop

    -- [value]
    ok set!

  def(build-block(scope, mod)):
    Atomy Compiler generate(mod file) [blk]:
      -- close over the outer scope
      blk state scope parent = scope

      blk total-args = 1
      blk required-args = 1
      blk arity = 1

      pairs = @branches collect [`(~pat: ~*body)]:
        [mod pattern(pat), `(do: ~*body)]

      -- create a local for the value being matched against
      blk state scope new-local(."arg:match-value")

      -- [node]
      blk push-local(0)

      done = blk new-label

      pairs each [pair]:
        pat = pair[0]
        body = pair[1]

        skip = blk new-label

        -- [pattern, node]
        mod compile(blk, pat)

        -- [pattern, node, pattern, node]
        blk dup-many(2)

        -- [node, pattern, pattern, node]
        blk swap

        -- [bool, pattern, node]
        blk send(.matches?, 1)

        -- [pattern, node]
        blk gif(skip)

        pat locals each [name]:
          assigned = assignment-local(blk, name)
          local = assigned[0]
          created = assigned[1]
          when(created):
            blk push-nil
            local set-bytecode(blk)
            blk pop

        -- [node, pattern]
        blk swap

        -- [#<Rubinius::VariableScope>, node, pattern]
        blk push-variables

        -- [node, #<Rubinius::VariableScope>, pattern]
        blk swap

        -- [<junk>]
        blk send(.assign, 2)

        -- []
        blk pop

        -- [value]
        mod compile(blk, body)

        -- [value]
        blk goto(done)

        -- [pattern, node]
        skip set!

        -- [node]
        blk pop

      -- []
      blk pop

      -- [value]
      blk push-undef

      -- [value]
      done set!

  def(assignment-local(gen, name)):
    var = gen state scope search-local(name)

    if(var && (var depth == 0))
      then: [var, false]
      else: [gen state scope new-local(name) nested-reference, true]

macro(~x rescue: ~*branches):
  rescue new(x, branches)
