use(require("core"))
use(require("define"))
use(require("data"))
use(require("control-flow"))
use(require("patterns"))

data(Particle(@receiver, @message, @arguments))

def(Particle call(*args) &blk):
  to-proc call(*args) &blk

Particle open:
  alias-method(.[], .call)

def(Particle to-proc):
  [*args] &blk:
    unless(args size >= arity):
      raise(ArgumentError new((("given " + args size to-s) + ", expected ") + arity to-s))

    [recv, cur] =
      if(@receiver equal?(_))
        then: [args[0], 1]
        else: [@receiver, 0]

    filled =
      @arguments collect [v]:
        if(v equal?(_) && (args size >= cur))
          then:
            cur += 1
            args[cur - 1]
          else:
            v

    recv __send__(@message, *filled) &blk

def(Particle arity):
  required-args = 0
  when(@receiver equal?(_)):
    required-args += 1

  @arguments each [v]:
    when(v equal?(_)):
      required-args += 1

  required-args

def(Particle == other):
  other is-a?(self class) && (
    (other receiver == @receiver) && (
      (other message == @message) && (
        other arguments == @arguments)))

def(Symbol call(recv)): to-proc call(recv)

def(Symbol arity): 1

macro(.[~a, ~*as]):
  `(Particle new(_, .[], [~a, ~*as]))

macro(.((~x)(~*as))):
  `(Particle new(_, .~x, [~*as]))

macro(.(~r (~x)(~*as))):
  `(Particle new(~r, .~x, [~*as]))

macro(.(~r [~*as])):
  `(Particle new(~r, .[], [~*as]))

macro(.~(x & Infix)):
  `(Particle new(
      ~(x left || '_)
      .~(StringLiteral new(x operator to-s))
      [~(x right)]))

particle-klass = Particle

Atomy Pattern open:
  self data(Particle(@receiver, @message, @arguments))

  def(Particle target): particle-klass

  def(Particle matches?(value)):
    when(value is-a?(Symbol)):
      value =! particle-klass new(_, value, [])

    unless(value is-a?(particle-klass)):
      return(false)

    when(value message != @message):
      return(false)

    unless(@receiver matches?(value receiver)):
      return(false)

    @arguments matches?(value arguments)

  def(Particle assign(scope, value)):
    when(value is-a?(Symbol)):
      value =! particle-klass new(_, value, [])

    @receiver assign(scope, value receiver)
    @arguments assign(scope, value arguments)


pattern(.(~r [~*as])):
  Atomy Patterns Particle new(
    pattern(r)
    .[]
    pattern(`[~*as]))

pattern(.[]):
  Atomy Code Pattern new(`(Atomy Pattern Equality new(.[])), [])

pattern(.~(x & Word)):
  Atomy Code Pattern new(`(Atomy Pattern Equality new(.~x)), [])

pattern(.(~(x & Word))!):
  Atomy Code Pattern new(`(Atomy Pattern Equality new(.(~x)!)), [])

pattern(.(~(x & Word))?):
  Atomy Code Pattern new(`(Atomy Pattern Equality new(.(~x)?)), [])

pattern(.[~a, ~*as]):
  recv-pattern = pattern('_)
  args-pattern = pattern(`[~a, ~*as])

  Atomy Code Pattern new(
    `(Atomy Pattern Particle new(~recv-pattern, .[], ~args-pattern))
    args-pattern locals)

pattern(.~(x & Infix)):
  recv-pattern = pattern(x left || '_)
  args-pattern = pattern(`[~(x right)])

  Atomy Code Pattern new(
    `(Atomy Pattern Particle new(~recv-pattern, .~(StringLiteral new(x operator to-s)), ~args-pattern))
    recv-pattern locals + args-pattern locals)

pattern(.((~x)(~*as))):
  recv-pattern = pattern('_)
  args-pattern = pattern(`[~*as])

  Atomy Code Pattern new(
    `(Atomy Pattern Particle new(~recv-pattern, .~x, ~args-pattern))
    args-pattern locals)

pattern(.(~r (~x)(~*as))):
  recv-pattern = pattern(r)
  args-pattern = pattern(`[~*as])

  Atomy Code Pattern new(
    `(Atomy Pattern Particle new(~recv-pattern, .~x, ~args-pattern))
    recv-pattern locals + args-pattern locals)
