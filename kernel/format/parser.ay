use("core")
use("define")
use("block")
use("control-flow")
use("grammar")
use("init")

Atomy Format open:
  parser(Parser):
    %atomy := Atomy Parser

    text(e) := [
      <(/"[^\\%#{Regexp quote(e)}]+"/)> { text }
      "\\" <(/"[%\(\)\{\}\[\]]"/)> { text }
      "\\" e=(%atomy(escape)) { e }
    ]

    nested(e) := c=(text(e)+) { init(Chunk, text: c join) }

    chunk := nested("")

    flagged := "%" fs=(flag*) s=(segment) { s flags = fs, s }

    flag := [
      "#" { Number new }
      "0" &("." /"\d"/ | /"\d"/) { ZeroPad new }
      "." <(/"\d+"/)> { init(Precision, value: text to-i) }
      <(/"\d+"/)> { init(Number, value: text to-i) }
      <(/"[\.\+\*=<>,\?]"/)> { init(Symbol, character: text) }
    ]

    segment := [
      "p" "(" s=(sub(")")) ")" ("(" p=(sub(")")) ")")? {
        Pluralize new [n]:
          n singular = s
          n plural = p
      }
      "l" "(" c=(sub(")")) ")" { init(Lowercase, content: c) }
      "c" "(" c=(sub(")")) ")" { init(Capitalize, content: c) }
      "u" "(" c=(sub(")")) ")" { init(Uppercase, content: c) }
      "j" cs=(("(" c=(sub(")")) ")" { c })+) { init(Justify, segments: cs) }
      "{" c=(sub("}")) "}" { init(Iterate, content: c) }
      bs=(("[" c=(sub("]")) "]" { c })+) ("(" d=(sub(")")) ")")? {
        init(Conditional, branches -> Array(bs), default -> d)
      }
      "_" { Skip new }
      "^" { Break new }
      "%" { Indirection new }
      "s" { String new }
      "d" { Decimal new }
      "x" { Hex new }
      "o" { Octal new }
      "b" { Binary new }
      "r" { Radix new }
      "f" { Float new }
      "e" { Exponent new }
      "g" { General new }
      "c" { Character new }
      "v" { Any new }
    ]

    sub(e) := as=((flagged | nested(e))*) {
      init(Formatter, segments -> Array(as))
    }

    root := x=(sub("")) !(/"."/) { x }


  Parser singleton:
    parse(source) :=
      new(source) onto:
        unless(parse):
          raise-error

        result
