use("core")
use("define")
use("block")
use("control-flow")
use("grammar")

Atomy Format open:
  parser(Parser):
    %atomy := Atomy Parser

    text(e) := [
      <(/"[^\\%#{Regexp quote(e)}]+"/)> { text }
      "\\" <(/"[%\(\)\{\}\[\]]"/)> { text }
      "\\" e=(%atomy(escape)) { e }
    ]

    nested(e) := c=(text(e)+) { Chunk new [n]: n text = c join }

    chunk := nested("")

    flagged := "%" fs=(flag*) s=(segment) { s flags = fs, s }

    flag := [
      "#" { Number new }
      "0" &("." /"\d"/ | /"\d"/) { ZeroPad new }
      "." <(/"\d+"/)> { Precision new [n]: n value = text to-i }
      <(/"\d+"/)> { Number new [n]: n value = text to-i }
      <(/"[\.\+\*=<>,\?]"/)> { Symbol new [n]: n character = text }
    ]

    segment := [
      "p" "(" s=(sub(")")) ")" ("(" p=(sub(")")) ")")? {
        Pluralize new [n]:
          n singular = s
          n plural = p
      }
      "l" "(" c=(sub(")")) ")" { Lowercase new [n]: n content = c }
      "c" "(" c=(sub(")")) ")" { Capitalize new [n]: n content = c }
      "u" "(" c=(sub(")")) ")" { Uppercase new [n]: n content = c }
      "j" cs=(("(" c=(sub(")")) ")" { c })+) { Justify new [n]: n segments = cs }
      "{" c=(sub("}")) "}" { Iterate new [n]: n content = c }
      bs=(("[" c=(sub("]")) "]" { c })+) ("(" d=(sub(")")) ")")? {
        Conditional new [n]:
          n branches = Array(bs)
          n default = d
      }
      "_" { Skip new }
      "^" { Break new }
      "%" { Indirection new }
      "s" { String new }
      "d" { Decimal new }
      "x" { Hex new }
      "o" { Octal new }
      "b" { Binary new }
      "r" { Radix new }
      "f" { Float new }
      "e" { Exponent new }
      "g" { General new }
      "c" { Character new }
      "v" { Any new }
    ]

    sub(e) := as=((flagged | nested(e))*) {
      Formatter new [n]: n segments = Array(as)
    }

    root := x=(sub("")) !(/"."/) { x }


  Parser singleton:
    parse(source) :=
      new(source) onto:
        unless(parse):
          raise-error

        result
