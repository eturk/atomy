use(require("core"))
use(require("define"))

and = class:
  def(initialize(a, b)):
    instance-variable-set("@a", a)
    instance-variable-set("@b", b)

  def(bytecode(gen, mod)):
    done = gen new-label

    mod compile(gen, @a)
    gen dup
    gen gif(done)

    gen pop
    mod compile(gen, @b)

    done set!

macro(~a && ~b):
  and new(a, b)

or = class:
  def(initialize(a, b)):
    instance-variable-set("@a", a)
    instance-variable-set("@b", b)

  def(bytecode(gen, mod)):
    done = gen new-label

    mod compile(gen, @a)
    gen dup
    gen git(done)

    gen pop
    mod compile(gen, @b)

    done set!

macro(~a || ~b):
  or new(a, b)

if-then-else = class:
  def(initialize(if, then, else)):
    instance-variable-set("@if", if)
    instance-variable-set("@then", then)
    instance-variable-set("@else", else)

  def(bytecode(gen, mod)):
    else = gen new-label
    done = gen new-label

    mod compile(gen, @if)
    gen gif(else)

    mod compile(gen, @then)
    gen goto(done)

    else set!
    mod compile(gen, @else)

    done set!

macro(if(~x) then: ~*y; else: ~*z):
  if-then-else new(x, `(do: ~*y), `(do: ~*z))

macro(when(~x): ~*y):
  `(if(~x) then: ~*y; else: nil)

macro(unless(~x): ~*y):
  `(if(~x) then: nil; else: ~*y)


while-loop = class:
  def(initialize(condition, body)):
    instance-variable-set("@condition", condition)
    instance-variable-set("@body", body)

  def(bytecode(gen, mod)):
    -- TODO: check_interrupts? how to test that?

    loop = gen new-label
    done = gen new-label

    loop set!

    mod compile(gen, @condition)
    gen gif(done)

    mod compile(gen, @body)
    gen pop
    gen goto(loop)

    done set!
    gen push-nil

macro(while(~condition): ~*body):
  while-loop new(condition, `(do: ~*body))


until-loop = class:
  def(initialize(condition, body)):
    instance-variable-set("@condition", condition)
    instance-variable-set("@body", body)

  def(bytecode(gen, mod)):
    -- TODO: check_interrupts? how to test that?

    loop = gen new-label
    done = gen new-label

    loop set!

    mod compile(gen, @condition)
    gen git(done)

    mod compile(gen, @body)
    gen pop
    gen goto(loop)

    done set!
    gen push-nil

macro(until(~condition): ~*body):
  until-loop new(condition, `(do: ~*body))


negate = class:
  def(initialize(node)):
    instance-variable-set("@node", node)

  def(bytecode(gen, mod)):
    done = gen new-label
    yes = gen new-label

    mod compile(gen, @node)
    gen git(yes)

    gen push-true
    gen goto(done)

    yes set!
    gen push-false

    done set!

macro(!~node):
  negate new(node)

return = class:
  def(initialize(node)):
    instance-variable-set("@node", node)

  def(bytecode(gen, mod)):
    mod compile(gen, @node)
    gen ret

macro(return(~node)):
  return new(node)

ensure = class:
  def(initialize(node, ensured)):
    instance-variable-set("@node", node)
    instance-variable-set("@ensured", ensured)

  -- TODO: this is pretty barebones compared to:
  -- https://github.com/rubinius/rubinius-ast/blob/aa5ff6260a7647a9ef1035feb66b6d4b632d4211/lib/rubinius/ast/exceptions.rb
  -- i'd rather prove out the complexiy than blindly mirror it
  def(bytecode(gen, mod)):
    ok = gen new-label
    ex = gen new-label

    gen setup-unwind(ex, 1) -- EnsureType

    mod compile(gen, @node)
    gen goto(ok)

    ex set!
    gen push-exception-state
    mod compile(gen, @ensured)
    gen pop
    gen restore-exception-state
    gen reraise

    ok set!
    mod compile(gen, @ensured)
    gen pop

macro(~node ensuring: ~*ensured):
  ensure new(node, `(do: ~*ensured))
