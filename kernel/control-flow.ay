use("core")
use("define")
use("node")

pairs = require("pairs")

infix("<- ->", 20, .right)
infix("while until", 5, .right)
infix("if unless", 5, .right)
infix("<=> < <= >= >", 60)
infix("== !=", 50)
infix("&& and", 40)
infix("|| or", 30)
infix("not", 45, .right)


macro(condition ~(b: Block)):
  pairs from(b contents) reverse inject('nil) [acc, [x, y]]:
    `(if(~x) then: ~y; else: ~acc)

macro(~val match ~(b: Block)):
  branches = pairs from(b contents) collect [x, y]:
    MatchBranch new [n]: n line = x line, n pattern = x, n branch = y

  Match new [n]: n target = val, n branches = branches

macro(~x rescue ~(y: Block)):
  branches = pairs from(y contents) collect [p, e]:
    RescueHandler new [n]: n line = p line, n pattern = p, n body = e

  Rescue new [n]:
    n body = x caller
    n handlers = branches

macro(~x rescue ~(y: Block) else ~(z: Block)):
  branches = pairs from(y contents) collect [p, e]:
    RescueHandler new [n]: n line = p line, n pattern = p, n body = e

  Rescue new [n]:
    n body = x caller
    n handlers = branches
    n else = z body


Atomy AST open:
  ast:
    And(.a, .b)
    Or(.a, .b)
    Negate(.expression)

  And bytecode(g, mod) := do:
    pos(g)
    done = g new-label
    no = g new-label

    mod compile(g, @a)
    g dup
    g gif(done)

    g pop
    mod compile(g, @b)

    done set!

  Or bytecode(g, mod) := do:
    pos(g)
    done = g new-label

    mod compile(g, @a)
    g dup
    g git(done)

    g pop
    mod compile(g, @b)

    done set!

  Negate bytecode(g, mod) := do:
    pos(g)
    done = g new-label
    yes = g new-label

    mod compile(g, @expression)
    g git(yes)

    g push-true
    g goto(done)

    yes set!
    g push-false

    done set!


macro(~a and ~b): And new [n]: n a = a, n b = b
macro(~a && ~b): And new [n]: n a = a, n b = b

macro(~a or ~b): Or new [n]: n a = a, n b = b
macro(~a || ~b): Or new [n]: n a = a, n b = b

macro(not ~a): Negate new [n]: n expression = a
macro(!~a): Negate new [n]: n expression = a

macro(~a != ~b): `!(~a == ~b)
macro(~a !~ ~b): `!(~a =~ ~b)
macro(~x ||= ~y): `(~x =! (~x || ~y))
macro(~x &&= ~y): `(~x =! (~x && ~y))


macro(~x if ~y): `(when(~y): ~x)
macro(~x unless ~y): `(unless(~y): ~x)

macro(if(~x) then ~(y: Block) else ~(z: Block)):
  IfThenElse new [n]: n condition = x, n then = y body, n else = z body

macro(otherwise): 'true

macro(return(~y)):
  Return new [n]: n value = y

macro(~x ensuring ~(y: Block)):
  Ensure new [n]: n body = x caller, n ensure = y body

macro(when(~c) ~(b: Block)):
  `(if(~c) then ~b else: nil)

macro(unless(~c) ~(b: Block)):
  `(if(~c) then: nil; else ~b)



Atomy AST open:
  ast:
    Break(.value)
    Next(.value)

  Break bytecode(g, mod) := do:
    pos(g)
    mod compile(g, @value)
    g raise-break

  Next bytecode(g, mod) := do:
    pos(g)
    mod compile(g, @value)
    g ret


macro(break):
  Break new [n]: n value = 'nil

macro(break(~x)):
  Break new [n]: n value = x

macro(next):
  Next new [n]: n value = 'nil

macro(next(~x)):
  Next new [n]: n value = x


Atomy AST open:
  ast:
    Super([.arguments], .splat?, .block?)

  Super bytecode(g, mod) := do:
    pos(g)

    @arguments each [a]:
      mod compile(g, a)

    when(@splat):
      mod compile(g, @splat)
      g cast-array

    if(@block)
      then: mod compile(g, @block)
      else: g push-nil

    name = nil
    when(g state super?):
      name =! g state super name

    g send-super(name, @arguments size, !!@splat)

macro(super):
  Super new

splat-from(arguments) = do:
  args = arguments dup

  splat =
    if(args last is-a(Atomy AST Prefix)? and
        args last receiver == "*" to-sym)
      then: args pop receiver
      else: nil

  [args, splat]

macro(super &~blk):
  Super new [n]: n block = blk

macro(super ~(blk: Block)):
  Super new [n]: n block = blk

macro(super(~*pRiNcEsS)):
  [args, splat] = splat-from(pRiNcEsS)
  Super new [n]: n arguments = args, n splat = splat

macro(super(~*as) ~(blk: Block)):
  [args, splat] = splat-from(as)
  Super new [n]: n arguments = args, n splat = splat, n block = blk

macro(super(~*as) &~blk):
  [args, splat] = splat-from(as)
  Super new [n]: n arguments = args, n splat = splat, n block = blk
