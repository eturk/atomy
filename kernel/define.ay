use(require("core"))

-- function definition
macro(fn((~(msg & Word))(~*args)): ~*body):
  Atomy Code DefineFunction new(msg text, `(do: ~*body), args)

macro(fn(~(msg & Word)): ~*body):
  Atomy Code DefineFunction new(msg text, `(do: ~*body), [])

macro(fn(~(msg & Word) &~blk): ~*body):
  Atomy Code DefineFunction new(msg text, `(do: ~*body), [], nil, blk)

macro(fn((~(msg & Word))(~*args) &~blk): ~*body):
  Atomy Code DefineFunction new(msg text, `(do: ~*body), args, nil, blk)

-- method definition
macro(def((~(msg & Word))(~*args)): ~*body):
  Atomy Code DefineMethod new(msg text, `(do: ~*body), args)

macro(def(~(msg & Word)): ~*body):
  Atomy Code DefineMethod new(msg text, `(do: ~*body), [])

macro(def(~(msg & Word) &~blk): ~*body):
  Atomy Code DefineMethod new(msg text, `(do: ~*body), [], nil, blk)

macro(def((~(msg & Word))(~*args) &~blk): ~*body):
  Atomy Code DefineMethod new(msg text, `(do: ~*body), args, nil, blk)

-- helper for adding a module to the constant scope
with-module = Class new:
  def(bytecode(gen, _)):
    gen push-self
    gen add-scope
    gen push-nil

-- class creation
macro(class: ~*body): `(Object class: ~*body)

macro(~parent class: ~*body):
  -- force it to return the class
  --
  -- TODO: this would be more elegant if placed after the splat, but that
  -- currently does not work
  body << 'self

  `(//Class new(~parent) module-eval:
      ~(with-module new)
      ~*body)
