use("atomy")

io = require("io")

nesting-level = dynamic(0)
running-stats = dynamic

data(Stats(@passed = 0, @failed = 0))

indented(s) = " " * (^nesting-level * 2) + s

colored(color, s) = do:
  unless(^(io OutputPort) tty?):
    return(s)

  codes = [
    .black
    .red
    .green
    .yellow
    .blue
    .magenta
    .cyan
    .white
  ]

  i"\e[3#{codes index(color)}m#{s}\e[0m"

submoduled &action = do:
  ctx = Atomy Module new
  ctx use(self)
  ctx module-exec &action


theorize &tests :=
  with(running-stats = Stats new):
    tests call
    puts("")

    stats = ^running-stats

    puts(
      f"total of %d tests (%s passed, %s failed)" [
        stats failed + stats passed
        colored(.green, stats passed)
        if(stats failed == 0)
          then: "0"
          else: colored(.red, stats failed)
      ])

    stats


describe(what) &body := do:
  puts(indented(f"- %s" [what]))

  with(nesting-level = ^nesting-level + 1):
    submoduled &body

  nil

alias-method(.context, .describe)


let(name) &body :=
  define-method(name):
    res = instance-exec &body

    singleton:
      define-method(name): res

    res

subject &body := def(.subject) &body


it(description) &tests := do:
  { submoduled &tests
    puts(indented(colored(.green, f"✓ %s" [description])))
  } rescue {
    e:
      when(^running-stats):
        ^running-stats failed += 1

      puts(indented(colored(.red, f"✗ %s" [description])))
      puts(
        indented(
          colored(
            .yellow
            f"  ` %s: %s" [
              e class name
              e message
            ])))

      e backtrace first((ENV["THERIE_BT_LIMIT"] or 5) to-i) each [l]:
        puts(indented(f"    %s" [colored(.cyan, l)]))
  } else:
    when(^running-stats):
      ^running-stats passed += 1

  nil


data(Actuality(@value = nil, @action = nil))

expect(value) := Actuality new(value)
expect &action := Actuality new(nil, action)

Actuality to := ExpectTo new(self)
Actuality to-not := ExpectTo new(self, true)


data(ExpectTo(@actual, @negated? = false))

ExpectTo(actual, negated) match(matcher) := do:
  matched = matcher matches?(actual)

  condition:
    negated and matched ->
      /raise(matcher negative-failure-message(actual))

    negated and not matched ->
      true

    not matched ->
      /raise(matcher failure-message(actual))
    
    negated -> true


data(Matcher)

Matcher matches(actual)? := /error(.not-implemented)
Matcher failure-message(actual) := /error(.not-implemented)
Matcher negative-failure-message(actual) := /error(.not-implemented)

Matcher data: EqualityMatcher(@value)
ExpectTo be(value) := match(EqualityMatcher new(value))
EqualityMatcher(value) matches(actual)? := actual value == value
EqualityMatcher(value) failure-message(actual) :=
  i"expected #{actual value} to be #{value}"
EqualityMatcher(value) negative-failure-message(actual) :=
  i"expected #{actual value} to not be #{value}, but it was"


Matcher data: RaiseMatcher(@exception, @message = nil)
ExpectTo raise(exception, message = nil) :=
  match(RaiseMatcher new(exception, message))
RaiseMatcher matches(actual)? :=
  actual action rescue {
    e:
      @raised = e
      @raised is-a(@exception)?
  } else: false
RaiseMatcher failure-message(actual) :=
  if(@raised)
    then: i"expected #{@exception}, got #{@raised class}: #{@raised}"
    else: i"expected #{@exception} but nothing was raised"
RaiseMatcher negative-failure-message(actual) :=
  i"expected #{@exception} to not be raised, but it was"


Matcher data: ErrorMatcher(@error)
ExpectTo error(error) := match(ErrorMatcher new(error))
ErrorMatcher matches(actual)? :=
  { with-restarts(errored(matched?) -> matched?):
      actual action call
      false
  } bind {
    (e: ExceptionError) ->
      raise(e exception)

    (e: Error):
      @errored = e
      /restart(.errored, e kind-of(@error)?)
  }
ErrorMatcher failure-message(actual) :=
  if(@errored)
    then: i"expected #{@error}, got #{@errored class}: #{@errored}"
    else: i"expected #{@error} but nothing was signalled"
ErrorMatcher negative-failure-message(actual) :=
  i"expected #{@error} to not be signalled, but it was"


Matcher data: KindMatcher(@class)
ExpectTo be-a(class) := match(KindMatcher new(class))
KindMatcher matches(actual)? := actual value is-a?(@class)
KindMatcher failure-message(actual) :=
  i"expected #{actual value} (#{actual value class}) to be a #{@class}"
KindMatcher negative-failure-message(actual) :=
  i"expected #{actual value} (#{actual value class}) to not be a #{@class}, but it was"
